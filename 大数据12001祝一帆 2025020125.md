## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      计算机与人工智能学院《人工智能程序设计》实验报告📝

| 专业                 | 学号         | 姓名         |
| :------------------- | ------------ | ------------ |
| 数据科学与大数据技术 | 2025020125   | 祝一帆       |
| **课程名称**         | **实验名称** | **完成日期** |
| 专业综合训练I        | 实训一       | 2022.03.18   |



[TOC]

### 一 实验目标

- 使用github托管代码；
- 掌握编程文档的撰写方法；
- 复习变量&函数，表达式的相关知识。	

### 二 实验要求

- 个人独立完成，积极动手编程；
- 鼓励与同学交流，但不能抄袭源码；
- 能完成实验说明文档的各个步骤并撰写此实验报告；
- 能演示实验过程并阐述功能的主要代码模块。
- 实验报告请突出自己的**想法**、**做法**、**心得体会**；

### 三 实验环境

例如：

- Pycharm、Github、Typora；
- 书：python编程导论



### 四 实验内容

> 报告的**主体部分**。详细说明每部分任务的任务描述、实现步骤、实现方法、测试说明、实现痕迹，实现方法请==突出重点==，不必泛泛而谈。
>
> 任务描述：简要说明此任务需要达到的目的；
>
> 实现步骤：实现此任务大致分为哪几个阶段步骤；
>
> 实现方法：实现这些步骤时用到了哪些主要的方法（数据结构、算法、编程技巧等）；
>
> 测试说明：设计测试样例说明任务完成情况；
>
> 实现过程：git 时间线展示和说明。

例如：

#### 1. What Would Python Display？（WWPD）

##### 任务1 Control

- 任务描述

  使用 Ok 测试你的知识，回答下面的“Python会显示什么”问题：

  python3 ok -q --local control -u

- 实现

  ```python
  >>> def xk(c, d):
  ...     if c == 4:
  ...         return 6
  ...     elif d >= 4:
  ...         return 6 + 7 + c
  ...     else:
  ...         return 25
  >>> xk(10, 10)
  23
  
  >>> xk(10, 6)
  23
  
  >>> xk(4, 6)
  6
  
  >>> xk(0, 0)
  25   	
  ```
  
  ```python
  >>> def how_big(x):
  ...     if x > 10:
  ...         print('huge')
  ...     elif x > 5:
  ...         return 'big'
  ...     elif x > 0:
  ...         print('small')
  ...     else:
  ...         print("nothing")
  >>> how_big(7)
  Out[0]:'big'
  
  >>> how_big(12)
  huge
  
  >>> how_big(1)
  small
  
  >>> how_big(-1)
  nothing
  ```
  
  ```python
  >>> n = 3
  >>> while n >= 0:
  ...     n -= 1
  ...     print(n)
  2
  1
  0
  -1
  ```
  
  ```python
  >>> positive = 28
  >>> while positive:
  ...    print("positive?")
  ...    positive -= 3
  positive?
  positive?
  positive?
  positive?
  positive?
  ...
  ```
  
  ```python
  >>> positive = -9
  >>> negative = -12
  >>> while negative:
  ...    if positive:
  ...        print(negative)
  ...    positive += 3
  ...    negative += 3
  -12
  -9
  -6
  ```

##### 任务2 Veritasiness

- 任务描述

  使用 Ok 测试你的知识，回答下面的“Python会显示什么”问题：

  python3 ok -q --local control -u

- 实现

  ```python
  >>> True and 13
  13
  
  >>> False or 0
  0
  
  >>> not 10
  False
  
  >>> not None
  True
  ```

  ```python
  >>> True and 1 / 0 and False
  ZeroDivisionError: division by zero
  >>> True or 1 / 0 or False
  True
  >>> True and 0
  0
  >>> False or 1
  1
  >>> 1 and 3 and 6 and 10 and 15
  15
  >>> -1 and 1 > 0
  True
  >>> 0 or False or 2 or 1 / 0
  2
  ```

  ```python
  >>> not 0
  True
  >>> (1 + 1) and 1
  1
  >>> 1/0 or True
  ZeroDivisionError: division by zero
  >>> (True or False) and False
  False
  ```

#### 2.Parsons问题

##### 任务1 Add in Range


- 任务描述

  完成 `add_in_range` ，返回 `start` 和 `stop` （包括）之间的所有整数和

  > add_in_range.py源代码文件在 parsons_probs 文件夹中，进入该文件夹目录，终端输入命令进行验证：
  >
  > ```
  > python3 -m doctest add_in_range.py
  > ```

  ```python
  def add_in_range(start, stop):
      """
      >>> add_in_range(3, 5)  # .Case 1
      12
      >>> add_in_range(1, 10)  # .Case 2
      55
      """
      "*** YOUR CODE HERE ***"
  ```

  

- 实现步骤

  在循环中从start开始累加，每次累加完后start+1，直到start大于stop停止循环，返回累加值

- 实现方法

  ```python
  def add_in_range(start, stop):
      """
      >>> add_in_range(3, 5)  # .Case 1
      12
      >>> add_in_range(1, 10)  # .Case 2
      55
      """
      "*** YOUR CODE HERE ***"
      sum = 0
      while stop >= start :
          sum += start
          start += 1
      return sum
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319161715.png)

  

- 实现过程

  下面是此任务时间线：

![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319161902.png)



##### 任务2 Digit Position Match


- 任务描述

  Digit Position Match 是指数字的倒数第 `i` 位的数就是 `i`，例如， `980` 有倒数第 `0` 位是 `0` ， `98276` 有 倒数第 `2` 位是 `2` 。编写函数来确定一个数字 `n` 是否有倒数第 `k` 位的数字/位置匹配。

  > digit_pos_match.py源代码文件在 parsons_probs 文件夹中，进入该文件夹目录，终端输入命令进行验证：
  >
  > ```
  > python3 -m doctest digit_pos_match.py
  > ```

  ```python
  def digit_pos_match(n, k):
      """
      >>> digit_pos_match(980, 0) # .Case 1
      True
      >>> digit_pos_match(980, 2) # .Case 2
      False
      >>> digit_pos_match(98276, 2) # .Case 3
      True
      >>> digit_pos_match(98276, 3) # .Case 4
      False
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  利用%和//运算在n中取出目标数位值，与k相比，若相等则返回True，否则返回False

- 实现方法

  ```python
  def digit_pos_match(n, k):
      """
      >>> digit_pos_match(980, 0) # .Case 1
      True
      >>> digit_pos_match(980, 2) # .Case 2
      False
      >>> digit_pos_match(98276, 2) # .Case 3
      True
      >>> digit_pos_match(98276, 3) # .Case 4
      False
      """
      "*** YOUR CODE HERE ***"
      n %= pow(10,k+1)
      n //= pow(10,k)
      if n == k :
          return True
      return False
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319162530.png)

  

- 实现过程

  下面是此任务时间线：

![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319162613.png)

#### 编程问题

##### 任务1 Falling Factorial


- 任务描述

  编写函数 `falling`，接受两个参数 `n` 和 `k` ， 返回 从 `n` 开始的倒数 `k` 个连续数字之积。当 `k` 为 `0` 时，函数返回`1`

  ```python
  def falling(n, k):
      """Compute the falling factorial of n to depth k.
  
      >>> falling(6, 3)  # 6 * 5 * 4
      120
      >>> falling(4, 3)  # 4 * 3 * 2
      24
      >>> falling(4, 1)  # 4
      4
      >>> falling(4, 0)
      1
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  在循环中累乘n，每次完成累乘后，n和k的值都减1，直到k减为0，返回累乘的值。

- 实现方法

  ```python
  def falling(n, k):
      """Compute the falling factorial of n to depth k.
  
      >>> falling(6, 3)  # 6 * 5 * 4
      120
      >>> falling(4, 3)  # 4 * 3 * 2
      24
      >>> falling(4, 1)  # 4
      4
      >>> falling(4, 0)
      1
      """
      "*** YOUR CODE HERE ***"
      result = 1
      while k > 0 :
          result *= n
          n -= 1
          k -= 1
      return result
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319163437.png)

  

- 实现过程

  下面是此任务时间线：

![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319163526.png)

##### 任务2 Sum Digits

- 任务描述

  编写函数接受非负整数，返回其数位之和。（提示：使用整数除和取模可能会有用！）

  ```python
  def sum_digits(y):
      """Sum all the digits of y.
  
      >>> sum_digits(10) # 1 + 0 = 1
      1
      >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
      12
      >>> sum_digits(1234567890)
      45
      >>> a = sum_digits(123) # make sure that you are using return rather than print
      >>> a
      6
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  在循环中取出y的每一个数位值进行累加，结束循环后返回累加值。

- 实现方法

  ```python
  def sum_digits(y):
      """Sum all the digits of y.
  
      >>> sum_digits(10) # 1 + 0 = 1
      1
      >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
      12
      >>> sum_digits(1234567890)
      45
      >>> a = sum_digits(123) # make sure that you are using return rather than print
      >>> a
      6
      """
      "*** YOUR CODE HERE ***"
      re = 0
      while y > 0 :
          tmp = y%10
          re += tmp
          y //= 10
      return re
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319163928.png)

  

- 实现过程

  下面是此任务时间线：

![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319164009.png)

#### 额外的实践

##### 任务1 WWPD： What If?

- 任务描述

  > 使用 Ok 测试你的知识，回答下面的“Python会显示什么”问题：
  >
  > ```
  > python3 ok -q --local if-statements -u
  > ```
  >
  > 提示： `print` （和 `return` 不同）不会退出函数

- 实现

  ```python
  >>> def ab(c, d):
  ...     if c > 5:
  ...         print(c)
  ...     elif c > 7:
  ...         print(d)
  ...     print('foo')
  >>> ab(10, 20)
  10
  foo
  ```

  ```python
  >>> def bake(cake, make):
  ...     if cake == 0:
  ...         cake = cake + 1
  ...         print(cake)
  ...     if cake == 1:
  ...         print(make)
  ...     else:
  ...         return cake
  ...     return make
  >>> bake(0, 29)
  1
  29
  Out[0]: 29
  
  >>> bake(1, "mashed potatoes")
  mashed potatoes
  Out[1]: 'mashed potatoes'
  ```


##### 任务2 K-Occurrence

- 任务描述

  完成函数 `k-occurrence` ，返回 数位 `k` 在 `num` 中出现的次数， `0` 被当作没有数位。

  > k_occurrence.py源代码文件在 parsons_probs 文件夹中，进入该文件夹目录，终端输入命令进行验证：
  >
  > ```
  > python3 -m doctest k_occurrence.py
  > ```


  ```python
  def k_occurrence(k, num):
      """
      >>> k_occurrence(5, 10)  # .Case 1
      0
      >>> k_occurrence(5, 5115)  # .Case 2
      2
      >>> k_occurrence(0, 100)  # .Case 3
      2
      >>> k_occurrence(0, 0)  # .Case 4
      0
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  在循环中取出num中的每一个数位，并对其与k进行比较，若相同则count递增，最后返回count的值。

- 实现方法

  ```python
  def k_occurrence(k, num):
      """
      >>> k_occurrence(5, 10)  # .Case 1
      0
      >>> k_occurrence(5, 5115)  # .Case 2
      2
      >>> k_occurrence(0, 100)  # .Case 3
      2
      >>> k_occurrence(0, 0)  # .Case 4
      0
      """
      "*** YOUR CODE HERE ***"
      count = 0
      while num > 0:
          tmp = num % 10
          if tmp == k:
              count += 1
          num //= 10
      return count
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319165202.png)

- 实现过程

  下面是此任务时间线：

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319165249.png)

##### 任务3 Double Eights

- 任务描述

  编写函数，接受一个数字并确定其是否包括两个相邻的 `8`

  ```
  def double_eights(n):
      """Return true if n has two eights in a row.
      >>> double_eights(8)
      False
      >>> double_eights(88)
      True
      >>> double_eights(2882)
      True
      >>> double_eights(880088)
      True
      >>> double_eights(12345)
      False
      >>> double_eights(80808080)
      False
      """
      "*** YOUR CODE HERE ***"
  ```

  使用Ok测试你的代码

  ```
  python3 ok --local -q double_eights
  ```

- 完成函数 `k-occurrence` ，返回 数位 `k` 在 `num` 中出现的次数， `0` 被当作没有数位。

  > k_occurrence.py源代码文件在 parsons_probs 文件夹中，进入该文件夹目录，终端输入命令进行验证：
  >
  > ```
  > python3 -m doctest k_occurrence.py
  > ```


  ```python
  def k_occurrence(k, num):
      """
      >>> k_occurrence(5, 10)  # .Case 1
      0
      >>> k_occurrence(5, 5115)  # .Case 2
      2
      >>> k_occurrence(0, 100)  # .Case 3
      2
      >>> k_occurrence(0, 0)  # .Case 4
      0
      """
      "*** YOUR CODE HERE ***"
  ```

- 实现步骤

  在循环中定义一个标志位，当一个位数为8时为1，在这个标志位为1并且当前数位也为8的时候返回True，如果处理循环也没有这样的情况的话，返回False。

- 实现方法

  ```python
  def double_eights(n):
      """Return true if n has two eights in a row.
      >>> double_eights(8)
      False
      >>> double_eights(88)
      True
      >>> double_eights(2882)
      True
      >>> double_eights(880088)
      True
      >>> double_eights(12345)
      False
      >>> double_eights(80808080)
      False
      """
      "*** YOUR CODE HERE ***"
      f = 0
      while n > 0 :
          tmp = n % 10
          if f == 1 and tmp == 8 :
              return True
          elif tmp == 8 :
              f = 1
          else :
              f = 0
          n //= 10
      return False
  ```

- 测试说明

  使用doctest对函数进行测试

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319164446.png)

- 实现过程

  下面是此任务时间线：

  ![](https://cdn.jsdelivr.net/gh/zhu-2002/img/20220319164623.png)

### 五 实验心得

> 总结自己的实现过程中产生的感受和心得，突出一分耕耘一分收获。

能够更加熟练地使用循环和相关表达式，其中关于vertasiness的问题中关于and和or的相关问题仍旧存在一些疑惑，在or的问题上，如果有异常的表达式是在正确的表达式前面的时候会先抛出异常，同样的，如果是正确的表达式在前则会直接返回True，在and问题上，当and前后的表达式都为真，则返回下文  ，or的话则是返回上文，与此同时，我也能感受到对于python的语法更加了解和熟悉。



### 六 附录

> 关于图床的使用说明：
>
> 本文档使用github图床，域名为：https://cdn.jsdelivr.net/gh/zhu-2002/img





